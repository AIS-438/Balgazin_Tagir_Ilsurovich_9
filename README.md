# Balgazin_Tagir_Ilsurovich_9
# Введение

На данный момент фреймворк Spring Boot стал стандартом для создания микросервисов и веб-приложений на языке Java. Spring Boot – это фреймворк, построенный на основе Spring Framework, который значительно упрощает создание автономных приложений корпоративного уровня. Одним из ключевых преимуществ Spring Boot является возможность упаковки приложения в исполняемый JAR-файл со встроенным веб-сервером (Tomcat, Jetty или Undertow), что устраняет необходимость развёртывания в отдельном контейнере сервлетов.

Развёртывание Java-приложений на базе фреймворка Spring Boot в промышленной (production) среде представляет собой комплексную задачу, требующую глубокого понимания как особенностей самого приложения, так и инфраструктурных компонентов операционной системы. В отличие от разработческого окружения, где приложение может быть запущено простой командой java -jar, промышленная эксплуатация предъявляет строгие требования к надёжности, безопасности, управляемости и производительности:

- Отказоустойчивость: приложение должно автоматически запускаться при старте сервера и перезапускаться в случае сбоя.
- Безопасность: приложение не должно работать от имени суперпользователя (root) и не должно напрямую занимать привилегированные порты (80, 443).
- Управляемость: необходим удобный доступ к логам и статусу процесса.

В современных Linux-системах стандартом де-факто для управления системными службами является systemd — менеджер системы и служб, который обеспечивает параллельный запуск сервисов, управление зависимостями, мониторинг состояния и автоматический перезапуск при сбоях. Интеграция Spring Boot приложений с systemd позволяет достичь уровня управляемости, сопоставимого с традиционными системными службами.

Другим критически важным аспектом промышленной эксплуатации является использование обратного прокси-сервера (reverse proxy). Размещение приложения за прокси-сервером, таким как Nginx или Apache HTTP Server, обеспечивает ряд существенных преимуществ: терминация SSL/TLS, балансировка нагрузки, кэширование статического контента, защита от атак и централизованное управление доступом.


Целью данного реферата является всестороннее рассмотрение вопросов, связанных с запуском и эксплуатацией Spring Boot приложений в промышленной среде с акцентом на настройку systemd и проксирование. Рассмотрены будут как теоретические основы, так и практические аспекты конфигурирования, включая готовые примеры конфигурационных файлов, рекомендации по безопасности и типичные проблемы с их решениями.

Для демонстрации процесса запуска приложения я реализовал простой Java Spring Boot сервис, работающий с БД SQLite. Он обладает одной ручкой «/api», к которой можно обращаться при помощи POST запроса:

```json
{
    "key": "string",
    "value": "string"
}
```

И при помощи GET-запроса вида:

192.168.0.109:8080/api/”ключ_записи”

Данный сервис реализует простую работы с БД: делает записи в БД и возвращает их по ключу, переданному в запросе

## Подготовка к развертыванию приложения

1) Сборка артефакта

Перед развертыванием необходимо собрать приложение в так называемый "Fat JAR" (исполняемый архив, содержащий все зависимости). Для этого необходимо выполнить команду «mvn clean package» (в случае, если используется сборщик Maven, как и в моем случае).


Рисунок 1. Команда «mvn clean package»

<img width="590" height="315" alt="image" src="https://github.com/user-attachments/assets/e862f926-8fe1-47a1-b0bb-bdd67b9b91df" />

В случае, если используется сборщик Gradle, необходимо выполнить команду «./gradlew build».

2) Профили конфигурации

Spring Boot поддерживает концепцию профилей, позволяющих определять различные конфигурации для разных сред выполнения. Для промышленной эксплуатации рекомендуется создать отдельный профиль production или prod.

3) Настройка параметров JVM

Для промышленной эксплуатации критически важна правильная настройка параметров виртуальной машины Java. Основные параметры включают:

```bash
JAVA_OPTS="-Xms512m -Xmx2048m \ -XX:+UseG1GC \ -XX:MaxGCPauseMillis=200 \ -XX:+HeapDumpOnOutOfMemoryError \ -XX:HeapDumpPath=/var/log/myapp/heapdump.hprof \ -Djava.security.egd=file:/dev/./urandom \ -Dfile.encoding=UTF-8"
```


Где:

-Xms512m — начальный размер кучи (heap)

-Xmx2048m — максимальный размер кучи

-XX:+UseG1GC — использование сборщика мусора G1, оптимизированного для приложений с большими объёмами памяти

-XX:MaxGCPauseMillis=200 — целевое время паузы сборки мусора

-XX:+HeapDumpOnOutOfMemoryError — создание дампа памяти при ошибке OutOfMemoryError

-Djava.security.egd — ускорение генерации случайных чисел

4) Graceful Shutdown

Spring Boot 2.3 и выше поддерживает плавное завершение работы (graceful shutdown), которое позволяет приложению завершить обработку текущих запросов перед остановкой. Эта функциональность особенно важна при работе с systemd, так как позволяет корректно обрабатывать сигналы остановки.

5) Создание выделенного пользователя

Запускать приложение от имени root — грубое нарушение безопасности. Если злоумышленник найдет уязвимость в приложении (RCE), он получит полный контроль над сервером. Соответственно, необходимо создать пользователя без домашней директории и возможности входа в shell. Для этого нужно выполнить команды:

```bash
sudo useradd -r -s /bin/false “имя_пользователя”
sudo chown -R “имя_пользователя”: “имя_пользователя” “путь_до_jar_файла”
```

Данный пользователь необходим для того, чтобы владеть процессом Java. Это необходимо для того, чтобы в случае, если злоумышленник взломает Java-приложение, он не смог получить root-права, а также не мог запустить консоль.


Рисунок 2. Создание выделенного пользователя

<img width="624" height="371" alt="image" src="https://github.com/user-attachments/assets/ebc91d85-3a80-4339-a0ca-22c73bfcd518" />


## Управление процессом с помощью systemd

Systemd — это ставшая стандартной в большинстве современных дистрибутивов Linux система инициализации и управления службами. Она позволяет превратить наше Java-приложение в фоновую службу (демона).

Systemd обеспечивает:

- Параллельный запуск служб для ускорения загрузки системы
- Управление зависимостями между службами
- Мониторинг состояния служб и автоматический перезапуск
- Централизованное управление журналами через journald
- Изоляцию служб с использованием cgroups

Для настройки Spring Boot приложения как systemd-сервиса необходимо создать файл конфигурации в директории /etc/systemd/system/. Файл обычно имеет расширение .service и называется в соответствии с именем приложения (например, demo.service). Для этого необходимо выполнить команду:

```bash
sudo nano /etc/systemd/system/название.service
```

В моем случае, это:

```bash
sudo nano /etc/systemd/system/demo.service
```

[Image: Page 5]

Далее необходимо задать конфигурацию сервиса. В этом файле указываются права пользователя, под которым будет запущено приложение, рабочая директория, команда запуска. Структура данного файла состоит из секций [Unit], [Service], [Install].

В секции Unit содержатся следующие параметры:

- Description – человекочитаемое описание службы
- Documentation – ссылка на документацию
- After – службы, после которых должна запускаться данная служба
- Requires – обязательные зависимости; при их сбое служба также остановится
- Wants – желательные зависимости; их сбой не влияет на данную службу

В секции Service:

- Type – тип службы: simple, forking, oneshot, notify
- User / Group – пользователь и группа для запуска
- WorkingDirectory – рабочий каталог
- ExecStart – команда запуска
- ExecStop – команда остановки
- Restart – политика перезапуска: no, on-success, on-failure, always
- RestartSec – задержка перед перезапуском
- TimeoutStopSec – время ожидания остановки перед принудительным завершением
- SuccessExitStatus – коды возврата, считающиеся успешными

Параметры безопасности:

- NoNewPrivileges – запрет получения новых привилегий
- ProtectSystem – защита системных каталогов (true, full, strict)
- ProtectHome – защита домашних каталогов
- PrivateTmp – изолированный /tmp
- ReadWritePaths – каталоги с доступом на запись

Важно использовать отдельного пользователя для запуска приложения, не использовать учетную запись root, чтобы минимизировать потенциальные риски безопасности.



Рисунок 3. Конфигурация сервиса

<img width="624" height="468" alt="image" src="https://github.com/user-attachments/assets/9297adeb-904a-48d6-b465-2884145bb60f" />


## Управление сервисом

После создания файла необходимо перезагрузить конфигурацию демонов и активировать сервис. Для этого необходимо выполнить следующие команды.

Обновить конфигурацию systemd:

```bash
sudo systemctl daemon-reload
```

Добавить сервис в автозагрузку:

```bash
sudo systemctl enable demo
```

Запустить сервис:

```bash
sudo systemctl start demo
```

Для проверки того, как работает сервис, можно выполнить следующие команды:

Проверить статус:

```bash
sudo systemctl status demo
```


Смотреть логи приложения:

```bash
sudo journalctl -u demo -f
```

Рисунок 4. Статус сервиса

<img width="624" height="313" alt="image" src="https://github.com/user-attachments/assets/1e7baf6d-05bb-4ecf-99be-a3bd5f83b1b1" />


Проверим, доступен ли сервис:

Рисунок 5. POST-запрос в сервис из хостовой ОС (Windows 10) при помощи Postman

<img width="569" height="404" alt="image" src="https://github.com/user-attachments/assets/7c418d7e-7d77-4211-b5b8-8b3423045e21" />


Рисунок 6. GET-запрос в сервис из хостовой ОС (Windows 10) при помощи Postman

<img width="631" height="445" alt="image" src="https://github.com/user-attachments/assets/c6ac955e-e75a-4a71-9a88-676d031c418b" />


Рисунок 7. GET-запрос в сервис из Виртуальной машины Linux Debian, где и развернут сервис при помощи `wget`

<img width="641" height="627" alt="image" src="https://github.com/user-attachments/assets/b5f613aa-aafe-49c0-a37d-f29e61a1e52a" />


## Типы служб в Systemd и их особенности

Systemd поддерживает несколько типов служб:

1) Type=simple (рекомендуется для Spring Boot):

- Процесс, указанный в ExecStart, является основным процессом службы
- Systemd считает службу запущенной сразу после `fork()`

2) Type=forking:

- Предполагает, что процесс выполняет `fork()` и родительский процесс завершается
- Требует указания PIDFile

[Image: Page 10]

3) Type=notify:

- Аналогичен simple, но служба отправляет уведомление о готовности
- Требует поддержки sd_notify() в приложении

4) Type=exec:

- Systemd ожидает успешного выполнения exec() перед переходом к зависимым службам

## Настройка обратного проксирования (Reverse Proxy) через Nginx

Обратное проксирование (Reverse Proxy) — это архитектурный паттерн, при котором промежуточный сервер (обратный прокси) принимает запросы от клиентов из интернета, перенаправляет их на один или несколько внутренних серверов (бэкенд-серверов), а затем возвращает ответ клиенту, как если бы ответ пришел от самого прокси.

Клиент при этом не знает о существовании внутренних серверов. Для него обратный прокси и есть единственная точка входа.

Использование обратного прокси перед Spring Boot приложением предоставляет множество преимуществ: балансировку нагрузки, SSL-терминацию, кеширование статического контента, защиту от DDoS-атак и возможность размещения нескольких приложений на одном сервере.

Nginx – это высокопроизводительный, асинхронный, модульный веб-сервер, который также может работать как обратный прокси, кэширующий сервер, балансировщик нагрузки и прокси для электронной почты (IMAP/POP3).

Преимущества использования Nginx:

- Терминация SSL/TLS — шифрование обрабатывается на уровне Nginx, освобождая ресурсы приложения
- Балансировка нагрузки — распределение запросов между несколькими экземплярами
- Кэширование — хранение статического контента и ответов
- Сжатие — уменьшение объёма передаваемых данных
- Защита — фильтрация вредоносных запросов
- Единая точка входа — централизованное управление маршрутизацией

Для установки nginx необходимо выполнить команду:

```bash
sudo apt install nginx
```

Предварительно рекомендуется обновить apt

```bash
sudo apt update
```

[Image: Page 11]

После установки создается конфигурационный файл для проксирования запросов к Spring Boot приложению. Конфигурационные файлы обычно размещаются в `/etc/nginx/sites-available/`, а затем создаются символические ссылки в `/etc/nginx/sites-enabled/` для активации конфигурации.

Для создания конфигурационного файла необходимо выполнить команду:

```bash
sudo nano /etc/nginx/sites-available/demo.com
```

Рисунок 8. Конфигурационный файл

<img width="600" height="367" alt="image" src="https://github.com/user-attachments/assets/24db2ade-98ac-4f3a-b208-bb4efe9eb094" />


Для корректной работы за обратным прокси необходимо настроить Spring Boot.

Через application.yml:

```yaml
server: port: 8080 forward-headers-strategy: native tomcat: remoteip: remote-ip-header: X-Forwarded-For protocol-header: X-Forwarded-Proto
```

[Image: Page 12]

Или через properties:

server.forward-headers-strategy=native

server.tomcat.remoteip.remote-ip-header=X-Forwarded-For

server.tomcat.remoteip.protocol-header=X-Forwarded-Proto


## Интеграция Spring Boot с обратным прокси

При размещении Spring Boot приложения за обратным прокси необходимо правильно настроить обработку заголовков для корректной работы редиректов и генерации URL.

Настройка порта и хоста

Рекомендуется настроить Spring Boot приложение на прослушивание только локального интерфейса (localhost), так как внешние запросы будут обрабатываться Nginx:

server.address=127.0.0.1

server.port=8080

Это повышает безопасность, так как приложение недоступно напрямую извне, только через прокси.

## Активация и нюансы

Для активации конфигурации необходимо выполнить команду:

```bash
sudo ln -s /etc/nginx/sites-available/demo.com /etc/nginx/sites-enabled/
```

Для проверки конфигурации:

```bash
sudo nginx –t
```

Для перезагрузки:

```bash
sudo systemctl reload nginx
```

[Image: Page 14]

## Заключение

Развертывание Java Spring Boot приложений в промышленной среде требует комплексного подхода. Простого запуска JAR-файла недостаточно для обеспечения надежности и безопасности.

Использование systemd позволяет:

- Интегрировать приложение в операционную систему как сервис.
- Обеспечить автоматический перезапуск при сбоях.
- Централизованно управлять логами через journalctl.
- Использование Nginx позволяет:
- Принимать трафик на стандартные порты (80/443).

[Image: Page 15]

 Обеспечить терминацию SSL (шифрование).
 Скрыть детали реализации бэкенда от внешнего мира.

Данная архитектура является "золотым стандартом" для развертывания одиночных Java-приложений на виртуальных серверах (VPS/VDS).
